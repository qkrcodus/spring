- 회원
기능 : create, read
등급 : 일반 , vip 두개
데이터 저장소는 미확정

- 주문과 할인 정책
모든 vip는 1000원씩 할인해주지만, 변동 가능성 매우 높다.

#### 역할과 구현을 나누자 

**내 생각엔**
- 데이터 저장소 인터페이스를 두어 저장 역할만 설계하고 DI 로 확정된 데이터 저장소 구현체를 회원 인터페이스에 주입한다

- 회원 인터페이스에 create, read 역할을 부여하고 등급 필드를 설정해둔다

- 할인 인터페이스 만들어 할인 역할을 부여하고 DI 로 확정된 할인 정책을 주문 클래스에 주입한다

- 주문 클래스는 바뀔 가능성이 없어 보이니 구체 클래스로 두고 할인 역할을 설계하고 할인 구현체를 이용하여 할인 금액을 구한다.

---
#### 회원 도메인 설계

![](https://i.imgur.com/kVenF9S.png)

![](https://i.imgur.com/VCGCvfB.png)

enum 으로 상수 관리 Grade => BASIC , VIP

< 회원 >
- 역할 ( 인터페이스 MemberService) -> join find 기능만 명시
- 역할 구현 객체 ( MemberServiceImpl ) -> 저장소에 join, find 구현
- 멤버 객체 ( Member )

< 저장소 >
- 역할 ( 인터페이스 , MemberMemberRepository) -> save find 기능만 명시
- 구현 객체 ( MemberRepository ) -> 저장소에 저장, 찾기 구현

[ 즉, 데이터를 표현하는 객체(예: Member, Customer 등)를 구체 클래스로 정의 , 역할(예: 데이터 생성, 조회, 수정, 삭제 등)을 인터페이스와 그 구현 클래스로 분리하자 ]

---
#### 테스트를 순수 자바로 설계 하는 경우

![](https://i.imgur.com/VbGEy69.png)

눈으로 확인 해야함 -> 권장 x

---
#### 테스트 라이브러리 junit 사용하는 경우

![](https://i.imgur.com/a0d21Pp.png)

이 코드의 설계상 문제점은 무엇일까요?
다른 저장소로 변경할 때 OCP 원칙을 잘 준수할까요?
DIP를 잘 지키고 있을까요?

**내 생각엔**

![](https://i.imgur.com/r59L8nR.png)

MemberServiceImpl 가 추상화에만 의존해야하는데 구체화된 구현체 MemoryMemberRepository 에 의존하고 있어서 DIP 를 위배하고

이로 인해, MemoryMemberRepository 가 아닌 다른 저장소로 변경되었을때 OCP원칙을 위배한다. 

---
#### 주문과 할인 도메인 설계

![](https://i.imgur.com/gFwpnVH.png)
인터페이스로 역할을
구현체로 구현을 분리하면, 구현 객체를 갈아 끼울 수 있다. 

1. 클라이언트가 orderserviceimpl에 주문 생성 ( 회원id, 상품명, 상품가격 )을 요청
2. 회원 등급 조회하기 위해 orderserviceimpl는 memberrepository에서 회원을 조회한다
3. orderserviceimpl는 회원 등급에 따라 할인 여부를 discountpolicy에 넘겨준뒤 결과를 클라이언트에게 반환한다

---
#### 주문과 할인 도메인 개발