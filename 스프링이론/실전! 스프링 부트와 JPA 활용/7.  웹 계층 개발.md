### 홈 화면과 레이아웃
- 스프링 개발 환경을 클라이언트로, H2 데이터베이스를 서버기 때문에 클라이언트(스프링 애플리케이션)는 데이터를 요청하고, 서버(H2 데이터베이스)는 그 요청을 수신하여 처리한다.
- 설정된 데이터베이스 URL을 사용하여 데이터베이스 서버에 연결을 시도하고 H2 데이터베이스 서버는 연결된 port 로 결과를 반환한다.
#### jpashop > controller > HomeController
- resources > static 에 js css 파일 넣어두자
- templates > 아래 html 파일 넣어두자
#### HomeController
![](https://i.imgur.com/NCBZ7Nf.png)

---
### 회원 등록

#### jpashop > controller > MemberForm
![](https://i.imgur.com/Qcu3q5U.png)
#### MemberController
![](https://i.imgur.com/VeOaIcg.png)

---
### 회원 목록 조회
entity 를 최대한 종속성 없고 순수하게 설계해야한다. 화면에 담는 api 는 dto 나 form 객체를 사용해야 한다.
api 를 만들땐 이유 불문하고 entity를 넘기면 안된다. 뿌려줄 내용만 뽑아서 dto로 만들어준다.
#### MemberController
![](https://i.imgur.com/OjL1Qcz.png)

---
### 상품 등록

#### jpashop > controller > BookForm
![](https://i.imgur.com/MnQ7VX6.png)

#### jpashop > controller > ItemController
여기서 setter 를 다 날리는 코드가 더 좋다고 한다. 수정한다면?
![](https://i.imgur.com/h7QRCo7.png)

setter 를 없애주는 이유는 객체 생성 후 내부 상태가 변경되지 않도록 함이다.
도메인 주도 설계에선 Book 엔티티를 아래와 같게 설계하고, 외부에서 생성자 호출하지 못하도록
protected Book( ) 해뒀다.
![](https://i.imgur.com/6bNFdgQ.png)

컨트롤러에선 Book 객체를 생성할때 이런식으로 
![](https://i.imgur.com/QgH3KIw.png)

---
### 상품 목록
#### ItemController
![](https://i.imgur.com/SpbKA7j.png)

---
### 상품 수정
jpa 에선 변경 감지, 병합으로 데이터를 수정한다. jpa 는 변경 감지 방법을 권장한다.
#### ItemController
![](https://i.imgur.com/ozhG6Bg.png)

![](https://i.imgur.com/WgcZBCh.png)

#### ItemRepository
잘 살펴보면 id 가 없는 경우 em.persist 로 새로운 객체를 데이터베이스에 넣어주고
존재하는 id 라면 em.merge 한다.
![](https://i.imgur.com/Of5vd8E.png)

---
### 변경 감지와 병합
정말 정말 중요하다고 한다.

---
#### 복습하고 가기

엔티티는 트랜잭션 커밋 후에 디비에 값을 넣어준다. 변경 감지 == dirty checking 으로 엔티티의 값을 업데이트 할 수 있다.
`@Transactional` 어노테이션이 적용된 서비스 계층에서 엔티티의 상태가 변경될 경우, 그 변경 사항이 트랜잭션이 종료될 때 자동으로 데이터베이스에 반영된다. ( 즉, 레포지토리 계층에서 em.persist 같은 작업 필요 x ) 

---
- 준영속 엔티티란?
영속성 컨텍스트가 관리했었는데 더는 관리하지 않는 엔티티를 말한다. 엔티티를 다시 디비에 반영하기 위해선 다시 영속 상태로 만들어야 한다. 
![](https://i.imgur.com/Qgut47A.png)

###### 준영속 엔티티를 update 해주기 위해선 두가지 방법이 있다.
1. merge
2. 준영속 엔티티지를 다시 service 계층에서 jpa 로 읽은 뒤, 변경 감지 기능 사용하기

#### 정리
- 새로운 엔티티 생성 -> 비영속 상태 -> 레포지토리 단계에서 em.persist
- 기존에 존재한 엔티티를 생성 -> 영속 상태 -> 레포지토리 단계에서 em.merge
- 기존에 존재한 엔티티를 업데이트 -> updateform 으로 받은 값을 엔티티에 저장 ( 비영속 상태 ) -> 서비스 단계에서 em.find ( 영속 상태 ) -> 레포지토리 단계에서 em 불필요

---
#### merge - 지양
#### ItemService
![](https://i.imgur.com/W1ShqKk.png)
#### ItemService
![](https://i.imgur.com/linwDkV.png)
#### ItemRepository
![](https://i.imgur.com/TQGj8GI.png)

- merger 사용 지양 : 병합시 값이 없으면 `null`로 업데이트 할 위험도 있다. (병합은 모든 필드를 교체한다.)
---
#### 변경 감지 - 지향
가급적이면 controller 에 엔티티를 생성하지 말자. ( update 시 )
#### ItemController
![](https://i.imgur.com/uXNLDDu.png)
#### ItemService
![](https://i.imgur.com/e64LtGM.png)
